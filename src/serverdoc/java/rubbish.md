<!--
 * @Descripttion: 
 * @version: 
 * @Author: suckson
 * @Date: 2019-09-03 10:36:57
 * @LastEditors: suckson
 * @LastEditTime: 2019-09-03 14:02:23
 -->
###  浅谈Java垃圾回收


##### 通用的分代垃圾回收机制

分代垃圾回收机制，是基于这样一个事实：不同的对象生命周期是不一样的。因此，不同生命周期的对象可以采用
不同的回收算法，以便提高回收的效率，我们将对象分为三种状态：年轻态、年老带、持久带。JVM将堆内存分为Eden、
Survivor和Tenured/Old空间。

1. 年轻代
   所有新生成的对象首先都是放在Eden区。年轻代的目标就是尽可能快速的收集掉那些生命周期短的对象，对应是Minor
GC, 对应的Minor Gc会清理年轻代的内存，算法采用效率较高的复制算法，删繁的操作。但是会浪费内存空间。当年轻代
区域存满对象后，就将对象存放到年老代区域。
2. 年老代
  在年轻代中经理了N默认15此垃圾回收后仍然存活的对象，就会放到年老代中。因此，可以认为年老代中存放的都是一些生命周期较长的对象，年老代对象越来越多，我们就需要启动Major Gc和Full Gc（全量回收），来一次大扫除，全面清理年轻代和年老代区域。
3. 持久代用于存放静态文件，如java类、方法、等、持久代对垃圾回收没有显著影响。

Minor GC:
用于清理年轻代区域。Eden区满了 就会触发-次Minor GC,清理无用对象,将有用对象复制
到"Survivor1”、 “Survivor2" 区中(这两个区,大小空间也相同,同-时刻Survivor1和
Survivor2只有一个在用。-个为空)
Major GC :
用于清理者年代区域。
Full GC :
用于清理年轻代、年者代区域。成本较高,会对系统性能产生影响。


垃圾回收过程:
1.新创建的对象,绝大多数都会存情在Eden中,
2.当Eden满了(达到-定比例)不能创新对象,则鲩发垃圾回收(GC) , 将无用对象清理掉,
然后剩余对象复制到某个Survivor中,如S1 ,同时清空Eden区
3.当Eden区再次满了，会将S1中的不能清空的对象存到另外-个Surivor中 ,如S2，
同时将Eden区中的不能清空的对象,也复制到S1中,保证Eden和S1 ,均被清空。
4.重复多次(默认15次)SurvIvor中没有被清理的对象,则会复制到老年代Old(Tenured)区中。

4.7.3 JVM调优和Full GC
在对JVM调优的过程中。很大一部分工作就是对于Full GC的调节。有如下原因可能导致Full GC :
1.年老代(Tenured)被写满
2.持久代(Perm)被写满
3.System.gc0被显式调用(程序建议GC启动,不是调用GC )
4._上- -次GC之后Heap的各域分配策略动态变化

